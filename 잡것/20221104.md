# 20221104

1. index Signatures
   오브젝트의 속성명을 아직 결정하지 못했으나, 속성의 형태를 알고 있을 때, index signature을 사용하여, 이름 대신 index를 프로퍼티의 이름으로 사용할 수 있다.
   ```ts
    interface myobj {
        [index: number]: string
    }
   ```
   주의1) index string, number 둘다 사용시 index string의 형태는 index number의 형태를 포함할 수 있어야 한다. index number는 string으로 간주 되기 때문이다.
    ```ts
    interface myobj {
        [index: number]: string
        [index: string]: number  // X 
    }

    interface myobj {
        [index: number]: string
        [index: string]: string[] // X
    } 

    interface Animal { 'name':string};
    interface Cat extends Animal{ 'color':string};
    interface StringArray {
        [index: number]: Cat;
        [index: string]: Animal; // O
    }

   ```
   주의2) string index로 'dictionary' 만들기 쉽다. string index를 사용하면, 나머지 모든 프로퍼티들도 공통된 형을 가져야 한다. string index는 obj.property 와 obj['propperty'] 둘 모두 값 참조에 활용될 수 있다는 것을 선언하는 것이기 때문이다. 그런데, 만약 string index 가 union 타입이면, 여러가지 타입을 프로퍼티로 가질 수 있다. 어쨌든 string index의 형과 나머지 프로퍼티의 형이 맞아야 한다.
   ```
    interface myobj {
        [index: string]: string,
        'property1': string
    }  이렇게? 

     interface myobj {
        [index: string]: string,
        [index: string]: string,
        'property1': string
    }  이렇게? // X
   ```
   주의3) readoonly index signature를 쓸 수 있다. 


2. Extending Types
   interface로 정의한 타입을 다른 interface 정의 타입이 상속받을 수 있다. 그것도 여러개 상속 받을 수 있다. 이로서, 지나치게 프로퍼티를 늘어 놓는 코드를 예방하고, 타입간의 연관성도 보여줄 수 있다. 
   ```ts
   interface profiletype {
        name: string,
        age: number,
        gender: string,
   }
   interface basicdatatype{
        purpose: string,
        importance: number,
   }
   interface mydiettype extends profiletype, basicdatatype{
        whatIate: string[],
        whenIate: Date[],
        HowMuchIate: number[]
   }
   ```


3. intersection Types
- & 기호로 두 타입을 묶어서, 새로운 타입을 만드는 것
- interface 와 intersection 의 차이는, 충돌을 다루는 방식이다(??)


4.  Generic Object Types
- 형태 변수(Generic)를 활용하여, 정의한 타입
- 형태 변수(Generic) string, array 등과 같은 데이터의 타입을 담는 변수이다. 
- 형태 변수(Generic)에 Generic Object Type을 대입할 수 있다. 
- genric이 없다면, 형태의 content의 형태에 따라, 서로 다른 형태를 정의해주어야 하는 번거로움이 있다. 그러면 또 이 형태를 인자로 사용하는 함수를 여러개 오버로딩 해주어야 한다. 
- Array 도 사실 Generic type이다.


5. ReadonlyArray Type
- 바뀌면 안되는 array 형태를 ReadonlyArray라고 한다.
- ReadonlyArray type을 인자로 받는 함수가 있을때, 우리는 해당 배열이 수정될 걱정없이 함수를 사용할 수 있다.
- ReadonlyArray는 생성자가 없다. 그래서 아래와 같이 일반 배열을 할당하여 만들 수 있다.
```ts
    const roarray: ReadonlyArray<string> = ['s','d','g'];
```
- Array<Type> 의 줄임이 Type[] 인것 처럼
- ReadonlyArray<Type>의 줄임은 다음과 같다. readonly Type[]
- readonlyArray에는 push가 없다
- ReadonlyArray<Type>에 Array<Type>을 할당 할 수 없다. 

6. Tuple Types
- 튜플이란, 길이 형태 순서가 정해져 있는 배열이다. 
- 예를 들어
```ts
    type mytupletype = [string, number, Date];
    const mytuple = ['tuple',12,'19991221'];
```
- 정의한 튜플의 형식, 갯수, 순서에 어긋난 값을 할당하려고 하면 오류가 난다.
- 튜플 형식도 분해하여, 함수의 인자로 전달 할 수 있다.
```ts
    function getTuple(mytuple:mytupletype){
        const [name, age, birth] = mytuple;
        console.log(name, age, birth);
    }
```
- 튜플 형식은 convention-based API에 유용하다. 잘 모르겠지만, 다양한 정보 묶음을 가져와 사용할 수 있는 API를 말하는 것이 아닐까? 그러나, 튜플을 분해하여 전달할 경우, 변수의 이름을 다시 지어주는 경우가 있기 때문에, 다른 개발자들이 바뀐 변수명을 못알볼 수 도 있으니, 튜플 사용에 주의하자.
- 튜플의 요소는 ?를 달아서 옵션으로 만들 수 있다. 다만 옵션요소를 튜플의 끝에 와야 하고, 전체 튜플의 길이에 영향을 준다.
- 튜플은 rest element를 가질 수 있다.
```ts
type StringNumberBooleans = [string, number, ...boolean[]];
// string, number 가 각각 튜플 인텍스 0,1번에 들어가는 데이터타입이고 갯수가 정해지지 않은 몇개의 boolean타입 값들이 튜플에 추가될 수 있다.
type StringBooleansNumber = [string, ...boolean[], number];
// string이 튜플의 첫번째 인덱스로 들어가고, 마지막 인텍스에 number형 데이터를 받는다. strin과 number 사이에는 몇개의 boolean값이 들어갈 수 있다.
type BooleansStringNumber = [...boolean[], string, number];
// ...
```
- rest element를 지닌 튜플을 함수의 매개변수형으로 정의하고, 그 형태의 인자를 건네줄 수 있다. 
```ts
function readButtonInput(...args: [string, number, ...boolean[]]) {
  const [name, version, ...input] = args;
  // ...
}
```

7. readonly tuple types
- readonly tuple 가능하다. 함수의 매개변수를 이 형으로 선언하는 건 바람직하다. 해당 함수에 대입되는 tuple이 변형될 여지가 없음을 알수있게 해주기 때문이다. 
- readonly tuple을 일반 변경가능한 tuple에 할당할 수 없다.


8. 자바스크립트의 객체란? 
타스 이번주 내로 다 읽고, 다음 주에 이 문서 읽자.
https://poiemaweb.com/ 우오오오오오.... 이웅모님 사이트였따!!!!!
자바스크립트 딥다이브 저자!! 오오오오오오오

생각을 좀더 하면서 짜기.. 된다가 아니라? 


